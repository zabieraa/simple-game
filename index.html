<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>ãƒ–ãƒ­ãƒƒã‚¯å´©ã—ï¼ˆã‚¶ãƒ“ã‚¨ãƒ©ãƒ¼é•·è°·å·ã¨ãŸã³ãŠï¼‰</title>
<style>
  :root { --panel:#171a2b; --text:#e6e8f2; }
  *{box-sizing:border-box}
  html, body { height:100%; }
  body{
    margin:0;background:#0b0e1a;color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Noto Sans JP","Yu Gothic",sans-serif;
    display:grid;place-items:center;min-height:100vh;
    overscroll-behavior: contain;
    -webkit-tap-highlight-color: transparent;
  }
  .wrap{width:min(980px,94vw)}
  header{display:grid;gap:.6rem;grid-template-columns:1fr auto;align-items:center;margin:12px 0}
  h1{margin:0;font-size:clamp(18px,2.6vw,24px)}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{
    background:#171a2b;color:#e6e8f2;border:1px solid #2b3050;padding:10px 12px;border-radius:12px;font:inherit;cursor:pointer
  }
  .controls button.muted{opacity:.7; border-style:dashed}
  .stat{display:flex;gap:10px;flex-wrap:wrap;background:#121426b8;border:1px solid #272b46;padding:8px 12px;border-radius:12px;font-variant-numeric:tabular-nums}
  .canvas-wrap{
    position:relative;border:1px solid #2a2f4d;border-radius:16px;overflow:hidden;box-shadow:0 10px 30px #0008;background:#060814;
    touch-action:none;
    -webkit-user-select:none; user-select:none;
  }
  canvas{
    display:block;width:100%;height:auto;
    touch-action:none;
  }
  .overlay{position:absolute;inset:0;display:none;place-items:center;pointer-events:none;text-align:center;padding:20px}
  .overlay .panel{
    pointer-events:auto;background:#0b0e1acc;border:1px solid #2a2f4d;border-radius:14px;padding:18px 20px;max-width:min(92%,820px);
    max-height:92vh; overflow:auto;
  }
  .overlay h2{margin:0 0 10px;font-size:clamp(18px,3vw,24px)}
  .overlay img{
    max-width:100%; height:auto; display:none; border-radius:12px;
    max-height:calc(92vh - 120px); object-fit:contain;
  }
  footer{opacity:.75;font-size:12px;margin:10px 2px 0; text-align:center}

  @media (max-width: 640px){
    .controls button { padding:12px 14px; border-radius:14px; }
    .stat{ padding:10px 14px; border-radius:14px; }
  }

  /* === ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ç”»åƒã®ã‚¢ãƒ”ãƒ¼ãƒ«ï¼ˆå‰å¾Œãƒã‚¦ãƒ³ãƒ‰ï¼‰ === */
  @keyframes popIn {
    0%   { transform: scale(.8); opacity:.0; }
    60%  { transform: scale(1.06); opacity:1; }
    100% { transform: scale(1); }
  }
  @keyframes scaleBounce {
    0%, 100% { transform: scale(1); }
    50%      { transform: scale(1.15); }
  }
  .appeal-scale {
    animation: popIn .42s ease-out both,
               scaleBounce 2.0s ease-in-out .42s infinite;
    will-change: transform;
  }
  @media (prefers-reduced-motion: reduce) {
    .appeal-scale { animation: none !important; }
  }

  /* === æ—¢å­˜ã®ã€Œå¤§ãã‚è¡¨ç¤ºã€æ ï¼ˆå¿…è¦ã«å¿œã˜ã¦ç¶™ç¶šä½¿ç”¨ï¼‰ === */
  .overlay .panel.big { max-width: min(99%, 1100px); padding: 12px 14px; }
  .overlay img.big    { max-height: 98vh; }

  /* === ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆãƒŸã‚¹æ™‚ã«ä½¿ç”¨ï¼‰ === */
/* iOS/Androidã®å‹•çš„ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆé«˜ã«å¯¾å¿œ */
@supports (height: 100dvh) {
  .overlay.full .panel { height: 100dvh; }
  .overlay.full img { max-height: calc(100dvh - 160px); }
}

/* ãƒãƒƒãƒç­‰ã®ã‚»ãƒ¼ãƒ•ã‚¨ãƒªã‚¢ä¸‹ç«¯ã«ä½™ç™½ã‚’ç¢ºä¿ï¼ˆå¿…è¦ãªã‚‰ï¼‰ */
@supports (padding: env(safe-area-inset-bottom)) {
  .overlay.full .panel { padding-bottom: env(safe-area-inset-bottom); }
}

  .overlay.full { padding: 0; }
  .overlay.full .panel{
    max-width: none;
    max-height: none;
    width: 100vw;
    height: 100vh;
    border-radius: 0;
    border: none;
    background: #0b0e1acc;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã•ã›ãªã„ */
  }
  .overlay.full img{
    max-width: 98vw;
    max-height: 98vh;
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ãƒ–ãƒ­ãƒƒã‚¯å´©ã—ï¼ˆã‚¶ãƒ“ã‚¨ãƒ©ãƒ¼é•·è°·å·ã¨ãŸã³ãŠï¼‰</h1>
      <div class="controls">
        <button id="btnStart">ã‚¹ã‚¿ãƒ¼ãƒˆ / ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        <button id="btnPause">ãƒãƒ¼ã‚º</button>
        <button id="btnSound" aria-pressed="true" aria-label="ã‚µã‚¦ãƒ³ãƒ‰ON/OFF">ğŸ”Š ã‚µã‚¦ãƒ³ãƒ‰ON</button>
        <span class="stat">
          ã‚¹ã‚³ã‚¢:<strong id="score">0</strong>ã€€
          æ®‹æ©Ÿ:<strong id="lives">3</strong>ã€€
          ã‚¹ãƒ†ãƒ¼ã‚¸:<strong id="stage">1</strong>
        </span>
      </div>
    </header>

    <div class="canvas-wrap">
      <canvas id="game" width="960" height="640" aria-label="ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ³ãƒã‚¹"></canvas>
      <div class="overlay" id="overlay">
        <div class="panel">
          <h2 id="overlayTitle">æº–å‚™OK</h2>
          <p id="overlayMsg">ã‚¹ã‚¿ãƒ¼ãƒˆã§é–‹å§‹ã€‚â† â†’ / ãƒã‚¦ã‚¹ / ã‚¿ãƒƒãƒã§æ“ä½œã€‚ï¼ˆR: ãƒªã‚¹ã‚¿ãƒ¼ãƒˆï¼‰</p>
          <img id="overlayImg" alt="overlay image" />
        </div>
      </div>
    </div>

    <footer>
      ã‚¶ãƒ“ã‚¨ãƒ©ãƒ¼é•·è°·å·ã¨ãŸã³ãŠã®ãƒ–ãƒ­ãƒƒã‚¯å´©ã—ã‚²ãƒ¼ãƒ ã€‚
    </footer>
  </div>

<script>
(() => {
  // ===== ã‚¹ãƒ†ãƒ¼ã‚¸æ§‹æˆ =====
  const STAGES = [
    { block: 'block.png',  bg: 'grh.png',  ballColor: '#ffd166', speedMul: 1.00 },
    { block: 'block2.png', bg: 'grh2.png', ballColor: '#7fd8ff', speedMul: 1.25 } // ã‚¹ãƒ†ãƒ¼ã‚¸2ã¯1.25å€
  ];
  const END_IMG_SRC   = 'end.png';
  const BALL_IMG_SRC  = 'kao.png';   // ãƒœãƒ¼ãƒ«ç”»åƒ
  const MISS_IMG_SRC  = 'kao2.png';  // ãƒŸã‚¹æ™‚ã®ç”»åƒ

  // ===== åŸºæº–ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ =====
  const ROWS=4, COLS=8;
  const TOP_OFFSET_BASE=10;
  const EXTRA_TOP_MARGIN_BASE=48;
  const PLAY_AREA_BASE=360;
  const PADDLE_GAP_BASE=230;
  const SIDE_PAD_BASE=18;
  const SIDE_GUTTER_BASE=38;

  const BRICK_SCALE = 0.55;

  // ã‚¹ãƒ”ãƒ¼ãƒ‰
  const SPEED_MULT=38;
  const BASE = {
    paddleW:110, paddleH:14, ballR:35, // ãƒœãƒ¼ãƒ«å¤§ãã‚
    startSpeed:5.3*SPEED_MULT, maxSpeed:14+3*SPEED_MULT
  };

  // ===== å½“ãŸã‚Šåˆ¤å®šã®èª¿æ•´ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ =====
  // æ•°å­—ã‚’ä¸‹ã’ã‚‹ã»ã©æ‹¾ã„ã«ããï¼ˆ=ãƒŸã‚¹ã«ãªã‚Šã‚„ã™ãï¼‰ãªã‚Šã¾ã™
  const HIT_TUNE = {
    edgeInflateRatio: 0.15, // é€£ç¶šåˆ¤å®šã§åºƒã’ã‚‹æ¨ªå¹…ï¼ˆãƒœãƒ¼ãƒ«åŠå¾„Ã—ã“ã®å‰²åˆï¼‰
    rectInflateRatio: 0.10, // çŸ©å½¢äº¤å·®ã®æ¨ªåºƒã’å¹…ï¼ˆåŒä¸Šï¼‰
    minOverlapPx: 5.5       // ã“ã‚Œæœªæº€ã®â€œã‹ã™ã‚Šâ€ã¯ç„¡åŠ¹
  };

  // ===== DOM =====
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d', { alpha: false });
  const scoreEl=document.getElementById('score');
  const livesEl=document.getElementById('lives');
  const stageEl=document.getElementById('stage');
  const overlay=document.getElementById('overlay');
  const overlayPanel=document.querySelector('.overlay .panel');
  const overlayTitle=document.getElementById('overlayTitle');
  const overlayMsg=document.getElementById('overlayMsg');
  const overlayImg=document.getElementById('overlayImg');
  const btnStart=document.getElementById('btnStart');
  const btnPause=document.getElementById('btnPause');
  const btnSound=document.getElementById('btnSound');

  // ===== åŠ¹æœéŸ³ =====
  const seHit   = new Audio('hit.mp3');   seHit.volume  = 0.6;  // ãƒ–ãƒ­ãƒƒã‚¯
  const seHit2  = new Audio('hit2.mp3');  seHit2.volume = 0.6;  // ãƒ–ãƒ­ãƒƒã‚¯(Stage2)
  const seKabe  = new Audio('kabe.mp3');  seKabe.volume = 0.55; // å£ï¼†å¤©äº•
  const seMiss  = new Audio('miss.mp3');  seMiss.volume = 0.7;  // ãƒŸã‚¹
  const seClap  = new Audio('clap.mp3');  seClap.volume = 0.7;  // ã‚¯ãƒªã‚¢
  let soundOn = (localStorage.getItem('soundOn') ?? '1') === '1';
  function applySoundState(){
    seHit.muted  = !soundOn;
    seHit2.muted = !soundOn;
    seKabe.muted = !soundOn;
    seMiss.muted = !soundOn;
    seClap.muted = !soundOn;
    btnSound.classList.toggle('muted', !soundOn);
    btnSound.setAttribute('aria-pressed', soundOn ? 'true' : 'false');
    btnSound.textContent = soundOn ? 'ğŸ”Š ã‚µã‚¦ãƒ³ãƒ‰ON' : 'ğŸ”‡ ã‚µã‚¦ãƒ³ãƒ‰OFF';
  }
  applySoundState();

  // ===== çŠ¶æ…‹ =====
  let blockImg=null, bgImg=null, endImg=null, ballImg=null, missImg=null;
  let state={}, running=false, paused=false, lastTime=0;

  // ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
  const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const bands=(t,p)=>Array.from({length:p+1},(_,i)=>Math.round(i*t/p));
  function updateHUD(){ scoreEl.textContent=state.score; livesEl.textContent=state.lives; stageEl.textContent=state.stage; }
  function showOverlay(t,m){ if(t!=null)overlayTitle.textContent=t; if(m!=null)overlayMsg.textContent=m; overlayImg.style.display='none'; overlay.style.display='grid'; }

  // ç”»åƒä»˜ãã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šbigImage / scale / noAnim / fullscreenï¼‰
  function showOverlayWithImage(t, m, img, opts = {}){
    const big        = !!opts.bigImage;
    const wantScale  = (typeof opts.scale === 'number') ? opts.scale : 1;
    const noAnim     = !!opts.noAnim;
    const fullscreen = !!opts.fullscreen;

    overlayTitle.textContent = t ?? '';
    overlayMsg.textContent   = m ?? '';

    // ã‚¯ãƒ©ã‚¹åˆæœŸåŒ–
    overlay.classList.toggle('full', fullscreen);
    overlayImg.classList.remove('appeal-scale','big');
    overlayPanel.classList.toggle('big', !fullscreen && big);
    overlayImg.style.transform = '';
    overlayImg.style.transformOrigin = 'center center';

    if(img){
      overlayImg.src = img.src;
      overlayImg.style.display='block';

      if (!noAnim && !fullscreen) overlayImg.classList.add('appeal-scale');
      if (!fullscreen && big)     overlayImg.classList.add('big');

      const applyScale = () => {
        if (wantScale === 1) return;
        const vw = window.innerWidth  * (fullscreen ? 0.98 : 0.92);
        const vh = window.innerHeight * (fullscreen ? 0.98 : 0.92);
        const iw = img.naturalWidth  || img.width  || overlayImg.naturalWidth  || overlayImg.width  || 1;
        const ih = img.naturalHeight || img.height || overlayImg.naturalHeight || overlayImg.height || 1;
        const maxScaleByW = vw / iw;
        const maxScaleByH = vh / ih;
        const maxScale    = Math.max(0.1, Math.min(maxScaleByW, maxScaleByH));
        const finalScale  = Math.min(wantScale, maxScale);
        overlayImg.style.transform = `scale(${finalScale})`;
      };

      if ((img.naturalWidth || img.width) && (img.naturalHeight || img.height)) {
        applyScale();
      } else {
        overlayImg.onload = () => { applyScale(); overlayImg.onload = null; };
      }
    }else{
      overlayImg.style.display='none';
    }
    overlay.style.display='grid';
  }

  function hideOverlay(){
    overlay.style.display='none';
    overlay.classList.remove('full');
    overlayImg.style.display='none';
    overlayImg.classList.remove('appeal-scale','big');
    overlayImg.style.transform = '';
    overlayPanel.classList.remove('big');
  }

  function fitCanvasToCSSPixelSize(){
    const ratio=window.devicePixelRatio||1, r=canvas.getBoundingClientRect();
    const w=Math.floor(r.width), h=Math.floor(r.height);
    if(canvas.width!==w*ratio||canvas.height!==h*ratio){ canvas.width=w*ratio; canvas.height=h*ratio; ctx.setTransform(ratio,0,0,ratio,0,0); }
  }
  function loadImage(src, {optional=false}={}){
    return new Promise((res)=>{
      const im=new Image();
      im.onload=()=>res(im);
      im.onerror=()=>res(optional?null:im);
      im.src=src;
    });
  }
  function keepSpeed(ball){
    const m = Math.hypot(ball.dx, ball.dy) || 1;
    const s = ball.targetSpeed ?? m;
    const k = s / m;
    ball.dx *= k; ball.dy *= k;
  }

  // ===== ã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®— =====
  function computeScale(){
    const headerH = document.querySelector('header').offsetHeight;
    const footerH = document.querySelector('footer').offsetHeight;
    const availableH = window.innerHeight - headerH - footerH - 16;
    const wrapW = document.querySelector('.wrap').clientWidth || 960;

    const imageW0 = Math.max(100, Math.round(wrapW - SIDE_PAD_BASE*2));
    const imageH0 = Math.round(imageW0*(ROWS/COLS));
    const desiredH0 = TOP_OFFSET_BASE + EXTRA_TOP_MARGIN_BASE + imageH0 + PLAY_AREA_BASE;

    const sH = availableH > 0 ? Math.min(1, availableH / desiredH0) : 1;
    return sH;
  }

  // ===== ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ & åˆæœŸåŒ– =====
  async function loadStageImages(stageIndex){
    const def = STAGES[Math.min(stageIndex, STAGES.length-1)];
    let [b, g] = await Promise.all([
      loadImage(def.block, {optional:true}),
      loadImage(def.bg,    {optional:true})
    ]);
    if(!b) b = blockImg;
    if(!g) g = bgImg;
    return [b||blockImg, g||bgImg];
  }

  async function layoutAndInit({keep=false, showReady=true, stageChange=false, newGame=false}={}){
    const wrapW=document.querySelector('.wrap').clientWidth || 960;
    const scale = computeScale();

    const TOP_OFFSET  = Math.round(TOP_OFFSET_BASE * scale);
    const EXTRA_TOP_MARGIN = Math.round(EXTRA_TOP_MARGIN_BASE * scale);
    const PLAY_AREA   = Math.round(PLAY_AREA_BASE * scale);
    const PADDLE_GAP  = Math.round(PADDLE_GAP_BASE * scale);
    const SIDE_PAD    = Math.round(SIDE_PAD_BASE * scale);
    const SIDE_GUTTER = Math.round(SIDE_GUTTER_BASE * scale);

    const imageW0 = Math.max(100, Math.round(wrapW - SIDE_PAD*2));
    const imageW  = Math.round(imageW0 * BRICK_SCALE);
    const imageH  = Math.round(imageW * (ROWS/COLS));

    const Wcss = wrapW;
    const Hcss = TOP_OFFSET + EXTRA_TOP_MARGIN + imageH + PLAY_AREA;

    canvas.style.width = Wcss + 'px';
    canvas.style.height= Hcss + 'px';
    fitCanvasToCSSPixelSize();

    const W = canvas.getBoundingClientRect().width;
    const H = canvas.getBoundingClientRect().height;

    // ã‚¹ãƒ†ãƒ¼ã‚¸æƒ…å ±ï¼ˆè‰²ï¼†ã‚¹ãƒ”ãƒ¼ãƒ‰å€ç‡ï¼‰
    const stageIndex = Math.min((state.stage || 1) - 1, STAGES.length - 1);
    const stageDef   = STAGES[stageIndex] || {};
    const speedMul   = stageDef.speedMul ?? 1.0;
    const ballColor  = stageDef.ballColor ?? '#ffd166';

    if(stageChange){
      [blockImg, bgImg] = await loadStageImages(stageIndex);
    }

    const startX = Math.round((Wcss - imageW)/2);
    const startY = TOP_OFFSET + EXTRA_TOP_MARGIN;

    const leftBound  = startX;
    const rightBound = startX + imageW;

    const bricksStartX = startX + SIDE_GUTTER;
    const usableW      = Math.max(60, imageW - SIDE_GUTTER*2);

    const colB = bands(usableW, COLS);
    const rowB = bands(imageH, ROWS);

    const srcColB=bands((blockImg?.width??600),COLS);
    const srcRowB=bands((blockImg?.height??360),ROWS);

    const bricks=[];
    for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
      bricks.push({
        r,c,
        x: bricksStartX + colB[c],
        y: startY + rowB[r],
        w: colB[c+1]-colB[c],
        h: rowB[r+1]-rowB[r],
        alive:true,
        sx:srcColB[c], sy:srcRowB[r],
        sw:srcColB[c+1]-srcColB[c], sh:srcRowB[r+1]-srcRowB[r]
      });
    }

    const paddle={ x:(leftBound + (imageW - BASE.paddleW*scale)/2), y:startY+imageH+PADDLE_GAP, w:BASE.paddleW*scale, h:BASE.paddleH*scale, speed:22*scale };

    const base=BASE.startSpeed*(W/960)*speedMul;
    const s=Math.hypot(base,base);
    const ball={ x:leftBound + imageW*0.5, y:paddle.y-20*scale, dx:(rand(-1,1)<0?-base:base), dy:-base,
                 r:BASE.ballR*scale, maxSpeed:(BASE.maxSpeed*(W/960))*speedMul,
                 targetSpeed:s };
    keepSpeed(ball);

    let baseState;
    if(newGame){
      baseState = { score:0, lives:3, stage:1 };
    }else if(state && (keep || stageChange)){
      baseState = { score:state.score, lives:3, stage:state.stage };
    }else{
      baseState = { score:0, lives:3, stage:state?.stage ?? 1 };
    }

    state = Object.assign(baseState, {
      W,H,startX,startY,imageW,imageH,
      leftBound, rightBound,
      bricks, bricksLeft:bricks.length,
      paddle, ball, keys:{left:false,right:false,a:false,d:false},
      won:false, wonStage:false, resumeReady:false, clapPlayed:state?.clapPlayed ?? false,
      scale, PADDLE_GAP, PLAY_AREA,
      ballColor
    });
    updateHUD();
    if(showReady) showOverlay(`æº–å‚™OKï¼ˆSTAGE ${state.stage}ï¼‰`,'ã‚¹ã‚¿ãƒ¼ãƒˆã§é–‹å§‹ / ã‚¿ãƒƒãƒæ“ä½œOK'); else hideOverlay();
  }

  // ===== æç”» =====
  function drawBg(){
    // å¤–ï¼ç™½
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, state.W, state.H);

    // å†…ï¼#111111
    ctx.fillStyle = '#111111';
    ctx.fillRect(state.leftBound, 0, state.rightBound - state.leftBound, state.H);

    // ãƒ–ãƒ­ãƒƒã‚¯é ˜åŸŸã¨åŒã˜ç¯„å›²ã§èƒŒæ™¯
    if(bgImg){
      const gutter = Math.round(SIDE_GUTTER_BASE * state.scale);
      ctx.drawImage(bgImg, state.startX + gutter, state.startY, state.imageW - gutter*2, state.imageH);
    }

    // å£ã‚¬ã‚¤ãƒ‰
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(state.leftBound + 0.5, 0);  ctx.lineTo(state.leftBound + 0.5, state.H);
    ctx.moveTo(state.rightBound - 0.5, 0); ctx.lineTo(state.rightBound - 0.5, state.H);
    ctx.stroke();
  }

  function drawBricks(){
    for(const b of state.bricks){
      if(!b.alive) continue;
      if(blockImg){
        ctx.drawImage(blockImg, b.sx,b.sy,b.sw,b.sh, b.x,b.y,b.w,b.h);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(b.x + 0.5, b.y + 0.5, b.w - 1, b.h - 1);
      }else{
        ctx.fillStyle='#334'; ctx.fillRect(b.x,b.y,b.w,b.h);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(b.x + 0.5, b.y + 0.5, b.w - 1, b.h - 1);
      }
    }
  }

  // ç”»åƒãƒœãƒ¼ãƒ«æç”»ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§è‰²å¡—ã‚Šï¼‰
  function drawBall(){
    const b = state.ball;
    if (ballImg) {
      const d = b.r * 2;
      const x = Math.round(b.x - b.r);
      const y = Math.round(b.y - b.r);
      ctx.save();
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.clip();
      ctx.drawImage(ballImg, x, y, d, d);
      ctx.restore();
    } else {
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fillStyle = (state.ballColor || '#ffd166');
      ctx.fill();
    }
  }

  // ===== ç‰©ç† =====
  function blockCollision(){
    const b=state.ball;
    for(const brick of state.bricks){
      if(!brick.alive) continue;
      if (b.x + b.r < brick.x || b.x - b.r > brick.x + brick.w ||
          b.y + b.r < brick.y || b.y - b.r > brick.y + brick.h) continue;

      const prevX=b.x - b.dx*0.010, prevY=b.y - b.dy*0.010;
      const hitL=prevX <= brick.x - b.r, hitR=prevX >= brick.x + brick.w + b.r;
      const hitT=prevY <= brick.y - b.r, hitB=prevY >= brick.y + brick.h + b.r;
      if (hitL || hitR) b.dx*=-1; else if (hitT || hitB) b.dy*=-1; else b.dy*=-1;

      keepSpeed(b);

      // ã‚¹ãƒ†ãƒ¼ã‚¸ã«å¿œã˜ãŸãƒ’ãƒƒãƒˆSEï¼ˆãƒ–ãƒ­ãƒƒã‚¯ï¼‰
      try {
        if (soundOn) {
          const st = state.stage || 1;
          const se = (st >= 2) ? seHit2 : seHit;
          se.currentTime = 0;
          se.play();
        }
      } catch(e){}

      brick.alive=false; state.bricksLeft--; state.score+=10; updateHUD();
      break;
    }
  }

  function update(dt){
    const {W,H,paddle,ball,keys,leftBound,rightBound}=state;
    keepSpeed(ball);

    if(keys.left||keys.a)  paddle.x -= paddle.speed*dt*60;
    if(keys.right||keys.d) paddle.x += paddle.speed*dt*60;
    paddle.x = clamp(paddle.x, leftBound, rightBound - paddle.w);

    // ==== ã‚µãƒ–ã‚¹ãƒ†ãƒƒãƒ—ï¼šæ§ãˆã‚è¨­å®šï¼ˆæ‹¾ã„ã™ãæŠ‘åˆ¶ï¼‰ ====
    const moveX = ball.dx * dt;
    const moveY = ball.dy * dt;
    const dist  = Math.hypot(moveX, moveY);
    // åŠå¾„ã®0.7ã”ã¨ã«1ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆä»¥å‰ã¯0.5ï¼‰ï¼æœ€ä½3ã‚¹ãƒ†ãƒƒãƒ—
    const steps = Math.max(3, Math.ceil(dist / Math.max(1, ball.r * 0.9)));

    for(let i=0;i<steps;i++){
      const prevX = ball.x;
      const prevY = ball.y;

      ball.x += (ball.dx*dt)/steps;
      ball.y += (ball.dy*dt)/steps;

      // å·¦å³ã®å£ãƒ’ãƒƒãƒˆï¼ˆSEï¼‰
      if(ball.x - ball.r < leftBound){
        ball.x=leftBound + ball.r; ball.dx*=-1; keepSpeed(ball);
        try { if(soundOn){ seKabe.currentTime = 0; seKabe.play(); } } catch(e){}
      }
      if(ball.x + ball.r > rightBound){
        ball.x=rightBound - ball.r; ball.dx*=-1; keepSpeed(ball);
        try { if(soundOn){ seKabe.currentTime = 0; seKabe.play(); } } catch(e){}
      }

      // å¤©äº•ãƒ’ãƒƒãƒˆï¼ˆSEï¼‰
      if(ball.y - ball.r < 0){
        ball.y = ball.r;
        ball.dy *= -1;
        keepSpeed(ball);
        try { if (soundOn) { seKabe.currentTime = 0; seKabe.play(); } } catch(e){}
      }

      // ==== ãƒ‘ãƒ‰ãƒ«å½“ãŸã‚Šåˆ¤å®šï¼ˆé€£ç¶šåˆ¤å®šï¼‹åŠå¾„è¾¼ã¿ãƒ»èª¿æ•´ç‰ˆï¼‰ ====
      if (ball.dy > 0) {
        // é€£ç¶šåˆ¤å®šï¼šä¸Šé¢(y = paddle.y - r)ã®é¢äº¤å·®
        const yTop = paddle.y - ball.r;
        if (prevY <= yTop && ball.y >= yTop) {
          const denom = Math.max(1e-6, (ball.y - prevY));
          const t = (yTop - prevY) / denom;
          const xHit = prevX + t * (ball.x - prevX);

          // ç«¯ã®æ‹¾ã„å¹…ã‚’ç¸®å°
          const edgeInfl = ball.r * HIT_TUNE.edgeInflateRatio;
          const leftB  = paddle.x - edgeInfl;
          const rightB = paddle.x + paddle.w + edgeInfl;
          const inRange = (xHit >= leftB && xHit <= rightB);
          const overlap = Math.min(xHit - leftB, rightB - xHit); // è¿‘ã„å´ã®ä½™è£•é‡

          if (inRange && overlap >= HIT_TUNE.minOverlapPx) {
            const rel   = (xHit - (paddle.x + paddle.w / 2)) / (paddle.w / 2);
            const angle = rel * (Math.PI * 0.35);
            const s     = Math.min(ball.targetSpeed, ball.maxSpeed);
            ball.dx = Math.sin(angle) * s;
            ball.dy = -Math.cos(angle) * s;
            ball.x = clamp(xHit, paddle.x + ball.r, paddle.x + paddle.w - ball.r);
            ball.y = yTop - 0.01;
            keepSpeed(ball);
            continue;
          }
        }

        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šåŠå¾„è¾¼ã¿ã®çŸ©å½¢äº¤å·®ï¼ˆæ¨ªåºƒã’ã‚’ç¸®å°ï¼‰
        const rectInfl = ball.r * HIT_TUNE.rectInflateRatio;
        if (
          ball.y + ball.r >= paddle.y && prevY <= paddle.y + paddle.h &&
          ball.x + rectInfl >= paddle.x && ball.x - rectInfl <= paddle.x + paddle.w
        ) {
          const rel   = (ball.x - (paddle.x + paddle.w / 2)) / (paddle.w / 2);
          const angle = rel * (Math.PI * 0.35);
          const s     = Math.min(ball.targetSpeed, ball.maxSpeed);
          ball.dx = Math.sin(angle) * s;
          ball.dy = -Math.cos(angle) * s;
          ball.y  = paddle.y - ball.r - 0.01;
          keepSpeed(ball);
        }
      }

      blockCollision();
      if(state.bricksLeft===0) break;
    }

    // ãƒŸã‚¹å‡¦ç†ï¼ˆè½ä¸‹ï¼‰
    if(ball.y - ball.r > H){
      const stageIndex = Math.min((state.stage || 1) - 1, STAGES.length - 1);
      const speedMul   = (STAGES[stageIndex]?.speedMul ?? 1.0);
      const base       = BASE.startSpeed * (W/960) * speedMul;
      const s          = Math.hypot(base,base);

      state.lives--; updateHUD(); running=false;

      try { if(soundOn){ seMiss.currentTime = 0; seMiss.play(); } } catch(e){}

      if(state.lives<=0){
        showOverlay('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼','ã‚¹ã‚¿ãƒ¼ãƒˆ / R ã§æœ€åˆã‹ã‚‰');
        state.resumeReady = false;
      }else{
        showOverlayWithImage(
          'ã€€',
          'New Yorkï¼ˆæ®‹æ©Ÿ '+state.lives+'ï¼‰',
          missImg,
          { fullscreen:true, scale:2.5, noAnim:true }
        );
        Object.assign(state.ball,{
          x:leftBound + (state.imageW*0.5),
          y:state.paddle.y-20*state.scale,
          dx:(rand(-1,1)<0?-base:base), dy:-base,
          targetSpeed:s,
          maxSpeed:(BASE.maxSpeed*(W/960))*speedMul
        });
        keepSpeed(state.ball);
        state.resumeReady = true;
      }
    }

    // ã‚¯ãƒªã‚¢åˆ¤å®š
    if(state.bricksLeft===0 && !state.won && !state.wonStage){
      const lastStage = (state.stage >= STAGES.length);
      running=false;
      if(lastStage){
        state.won=true;
        try { if(soundOn && !state.clapPlayed){ seClap.currentTime=0; seClap.play(); state.clapPlayed=true; } } catch(e){}
        showOverlayWithImage('', 'ã‚¹ã‚¿ãƒ¼ãƒˆ / R ã§æœ€åˆã‹ã‚‰', endImg);
      }else{
        state.wonStage=true;
        showOverlay(`STAGE ${state.stage} CLEAR`, `ã‚¹ã‚¿ãƒ¼ãƒˆã§ STAGE ${state.stage+1} ã¸`);
      }
    }
  }

  // ===== ãƒ«ãƒ¼ãƒ— =====
  function loop(ts){
    if(!running || paused){ lastTime=ts; requestAnimationFrame(loop); return; }
    const dt=Math.min(0.033,(ts-lastTime)/1000)||0.016; lastTime=ts;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBg(); drawBricks(); drawPaddle(); drawBall(); update(dt);
    requestAnimationFrame(loop);
  }

  // ===== å…¥åŠ› / UI =====
  async function startGame(forceReset=false){
    // ãƒŸã‚¹å¾Œã®ç¶šã
    if(!forceReset && state.resumeReady && state.lives > 0 && !state.won && !state.wonStage){
      hideOverlay(); state.resumeReady = false; running = true; paused = false; return;
    }
    // æ¬¡ã‚¹ãƒ†ãƒ¼ã‚¸ã¸
    if(state.wonStage && !state.won){
      state.wonStage=false;
      state.stage += 1; updateHUD();
      await layoutAndInit({keep:false, showReady:false, stageChange:true, newGame:false});
      hideOverlay(); running=true; paused=false; return;
    }
    // æ–°è¦ / å®Œå…¨ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
    hideOverlay();
    state.clapPlayed=false;
    state.score=0; state.lives=3; state.stage=1; state.won=false; state.wonStage=false;
    await layoutAndInit({keep:false, showReady:false, stageChange:true, newGame:true});
    running=true; paused=false;
  }

  function drawPaddle(){ const p=state.paddle; ctx.fillStyle='#e2e5ff'; ctx.fillRect(p.x,p.y,p.w,p.h); }

  function togglePause(){ if(!running) return; paused=!paused; if(paused) showOverlay('ãƒãƒ¼ã‚º','ã‚¹ã‚¿ãƒ¼ãƒˆ / ãƒãƒ¼ã‚ºã§å†é–‹'); else hideOverlay(); }

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼ˆPCï¼‰
  window.addEventListener('keydown',e=>{
    if(['ArrowLeft','ArrowRight','Space','KeyA','KeyD','KeyR'].includes(e.code)) e.preventDefault();
    if(e.code==='ArrowLeft') state.keys.left=true;
    if(e.code==='ArrowRight') state.keys.right=true;
    if(e.code==='KeyA') state.keys.a=true;
    if(e.code==='KeyD') state.keys.d=true;
    if(e.code==='Space'){ if(!running) startGame(); else togglePause(); }
    if(e.code==='KeyR'){ startGame(true); }
  }, { passive:false });
  window.addEventListener('keyup',e=>{
    if(e.code==='ArrowLeft') state.keys.left=false;
    if(e.code==='ArrowRight') state.keys.right=false;
    if(e.code==='KeyA') state.keys.a=false;
    if(e.code==='KeyD') state.keys.d=false;
  });

  // ã‚¿ãƒƒãƒ/ãƒã‚¦ã‚¹ï¼ˆã‚¹ãƒãƒ›å‘ã‘ï¼‰
  function movePaddleByClientX(clientX){
    const r=canvas.getBoundingClientRect();
    const mid=(clientX - r.left) - state.paddle.w/2;
    state.paddle.x = clamp(mid, state.leftBound, state.rightBound - state.paddle.w);
  }
  canvas.addEventListener('pointerdown', e=>{ e.preventDefault(); movePaddleByClientX(e.clientX); }, { passive:false });
  canvas.addEventListener('pointermove', e=>{ e.preventDefault(); movePaddleByClientX(e.clientX); }, { passive:false });

  btnStart.addEventListener('click',()=>startGame());
  btnPause.addEventListener('click',()=>togglePause());
  btnSound.addEventListener('click',()=>{
    soundOn = !soundOn;
    localStorage.setItem('soundOn', soundOn ? '1':'0');
    applySoundState();
  });

  // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚¯ãƒªãƒƒã‚¯ã§é–‹å§‹/å†é–‹/ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
  function handleOverlayClick(){
    if (getComputedStyle(overlay).display === 'none') return;
    if (paused) { togglePause(); return; }
    startGame();
  }
  overlayPanel.addEventListener('click', (e) => {
    e.preventDefault(); e.stopPropagation(); handleOverlayClick();
  });
  overlayImg.addEventListener('click', (e) => {
    e.preventDefault(); e.stopPropagation(); handleOverlayClick();
  });

  // èµ·å‹•æ™‚ãƒ­ãƒ¼ãƒ‰
  (async ()=>{
    try{
      [blockImg,bgImg,endImg,ballImg,missImg]=await Promise.all([
        loadImage(STAGES[0].block),
        loadImage(STAGES[0].bg),
        loadImage(END_IMG_SRC),
        loadImage(BALL_IMG_SRC, {optional:true}),
        loadImage(MISS_IMG_SRC, {optional:true})
      ]);
    }catch{}
    await layoutAndInit({keep:false, showReady:true, stageChange:false, newGame:true});
    showOverlay('æº–å‚™OKï¼ˆSTAGE 1ï¼‰','ã‚¹ã‚¿ãƒ¼ãƒˆã§é–‹å§‹ã€‚ã‚¿ãƒƒãƒã§ãƒ‘ãƒ‰ãƒ«ã‚’å‹•ã‹ã›ã¾ã™ã€‚');
    requestAnimationFrame(loop);
  })();

  // ãƒªã‚µã‚¤ã‚º
  window.addEventListener('resize',()=>{
    if(state?.won) return;
    const run=running;
    layoutAndInit({keep:true, showReady:!run, stageChange:false, newGame:false});
    const ratio=window.devicePixelRatio||1; ctx.setTransform(ratio,0,0,ratio,0,0);
    if(run) hideOverlay();
  });

  // è‡ªå‹•å†ç”Ÿåˆ¶é™å¯¾ç­–ï¼ˆå„SEã‚’è§£éŒ ï¼‰
  window.addEventListener('pointerdown', () => {
    try { seHit.play().then(()=>seHit.pause()); } catch(e){}
    try { seHit2.play().then(()=>seHit2.pause()); } catch(e){}
    try { seKabe.play().then(()=>seKabe.pause()); } catch(e){}
    try { seMiss.play().then(()=>seMiss.pause()); } catch(e){}
    try { seClap.play().then(()=>seClap.pause()); } catch(e){}
  }, { once:true });

})();
</script>
</body>
</html>
