<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>ブロック崩し（ボンプとたびお）</title>
<style>
  :root { --panel:#171a2b; --text:#e6e8f2; }
  *{box-sizing:border-box}
  html, body { height:100%; }
  body{
    margin:0;background:#0b0e1a;color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Noto Sans JP","Yu Gothic",sans-serif;
    display:grid;place-items:center;min-height:100vh;
    overscroll-behavior: contain;
    -webkit-tap-highlight-color: transparent;
  }
  .wrap{width:min(980px,94vw)}
  header{display:grid;gap:.6rem;grid-template-columns:1fr auto;align-items:center;margin:12px 0}
  h1{margin:0;font-size:clamp(18px,2.6vw,24px)}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{
    background:#171a2b;color:#e6e8f2;border:1px solid #2b3050;padding:10px 12px;border-radius:12px;font:inherit;cursor:pointer
  }
  .controls button.muted{opacity:.7; border-style:dashed}
  .stat{display:flex;gap:10px;flex-wrap:wrap;background:#121426b8;border:1px solid #272b46;padding:8px 12px;border-radius:12px;font-variant-numeric:tabular-nums}
  .canvas-wrap{
    position:relative;border:1px solid #2a2f4d;border-radius:16px;overflow:hidden;box-shadow:0 10px 30px #0008;background:#060814;
    touch-action:none;
    -webkit-user-select:none; user-select:none;
  }
  canvas{
    display:block;width:100%;height:auto;
    touch-action:none;
  }
  .overlay{position:absolute;inset:0;display:none;place-items:center;pointer-events:none;text-align:center;padding:20px}
  .overlay .panel{
    pointer-events:auto;background:#0b0e1acc;border:1px solid #2a2f4d;border-radius:14px;padding:18px 20px;max-width:min(92%,820px);
    max-height:92vh; overflow:auto; /* 画面内に収める */
  }
  .overlay h2{margin:0 0 10px;font-size:clamp(18px,3vw,24px)}
  .overlay img{
    max-width:100%; height:auto; display:none; border-radius:12px;
    max-height:calc(92vh - 120px); object-fit:contain; /* 全体が入る */
  }
  footer{opacity:.75;font-size:12px;margin:10px 2px 0; text-align:center}

  /* スマホでのタップしやすさ強化 */
  @media (max-width: 640px){
    .controls button { padding:12px 14px; border-radius:14px; }
    .stat{ padding:10px 14px; border-radius:14px; }
  }

  /* === エンディング画像のアピールアニメ === */
  @keyframes popIn {
    0%   { transform: scale(.8); opacity:.0; }
    60%  { transform: scale(1.06); opacity:1; }
    100% { transform: scale(1); }
  }
  @keyframes scaleBounce {
    0%, 100% { transform: scale(1); }
    50%      { transform: scale(1.15); } /* 手前に出る度合い */
  }
  .appeal-scale {
    animation: popIn .42s ease-out both,
               scaleBounce 2.0s ease-in-out .42s infinite;
    will-change: transform;
  }
  @media (prefers-reduced-motion: reduce) {
    .appeal-scale { animation: none !important; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ブロック崩し（ボンプとたびお）</h1>
      <div class="controls">
        <button id="btnStart">スタート / リスタート</button>
        <button id="btnPause">ポーズ</button>
        <button id="btnSound" aria-pressed="true" aria-label="サウンドON/OFF">🔊 サウンドON</button>
        <span class="stat">
          スコア:<strong id="score">0</strong>　
          残機:<strong id="lives">5</strong>　
          ステージ:<strong id="stage">1</strong>
        </span>
      </div>
    </header>

    <div class="canvas-wrap">
      <canvas id="game" width="960" height="640" aria-label="ゲームキャンバス"></canvas>
      <div class="overlay" id="overlay">
        <div class="panel">
          <h2 id="overlayTitle">準備OK</h2>
          <p id="overlayMsg">スタートで開始。← → / マウス / タッチで操作。（R: リスタート）</p>
          <img id="overlayImg" alt="ending" />
        </div>
      </div>
    </div>

    <footer>
      ボンプたびおのブロック崩しゲーム。
    </footer>
  </div>

<script>
(() => {
  // ===== ステージ構成（Stage2: 水色 & 速度1.05） =====
  const STAGES = [
    { block: 'block.png',  bg: 'grh.png',  ballColor: '#ffd166', speedMul: 1.00 },
    { block: 'block2.png', bg: 'grh2.png', ballColor: '#7fd8ff', speedMul: 1.25 }
  ];
  const END_IMG_SRC = 'end.png';

  // ===== 基準レイアウト =====
  const ROWS=4, COLS=8;
  const TOP_OFFSET_BASE=10;
  const EXTRA_TOP_MARGIN_BASE=48;
  const PLAY_AREA_BASE=360;
  const PADDLE_GAP_BASE=230;
  const SIDE_PAD_BASE=18;
  const SIDE_GUTTER_BASE=38;

  const BRICK_SCALE = 0.55;

  // スピード
  const SPEED_MULT=38;
  const BASE = {
    paddleW:110, paddleH:14, ballR:8,
    startSpeed:5.3*SPEED_MULT, maxSpeed:14+3*SPEED_MULT
  };

  // ===== DOM =====
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d', { alpha: false });
  const scoreEl=document.getElementById('score');
  const livesEl=document.getElementById('lives');
  const stageEl=document.getElementById('stage');
  const overlay=document.getElementById('overlay');
  const overlayTitle=document.getElementById('overlayTitle');
  const overlayMsg=document.getElementById('overlayMsg');
  const overlayImg=document.getElementById('overlayImg');
  const btnStart=document.getElementById('btnStart');
  const btnPause=document.getElementById('btnPause');
  const btnSound=document.getElementById('btnSound');

  // ===== 効果音（BGMはナシ） =====
const seHit  = new Audio('hit.mp3');   seHit.volume  = 0.6;
const seClap = new Audio('clap.mp3');  seClap.volume = 0.7;

// ★ 追加：ステージ2用ヒット音
const seHit2 = new Audio('hit2.mp3');  seHit2.volume = 0.6;
  let soundOn = (localStorage.getItem('soundOn') ?? '1') === '1';
  function applySoundState(){
  seHit.muted  = !soundOn;
  seClap.muted = !soundOn;
  seHit2.muted = !soundOn; // ★ 追加
  btnSound.classList.toggle('muted', !soundOn);
  btnSound.setAttribute('aria-pressed', soundOn ? 'true' : 'false');
  btnSound.textContent = soundOn ? '🔊 サウンドON' : '🔇 サウンドOFF';
}
  applySoundState();

  // ===== 状態 =====
  let blockImg=null, bgImg=null, endImg=null;
  let state={}, running=false, paused=false, lastTime=0;

  // ===== ユーティリティ =====
  const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const bands=(t,p)=>Array.from({length:p+1},(_,i)=>Math.round(i*t/p));
  function updateHUD(){ scoreEl.textContent=state.score; livesEl.textContent=state.lives; stageEl.textContent=state.stage; }
  function showOverlay(t,m){ if(t!=null)overlayTitle.textContent=t; if(m!=null)overlayMsg.textContent=m; overlayImg.style.display='none'; overlay.style.display='grid'; }
  function showOverlayWithImage(t, m, img){
    overlayTitle.textContent = t ?? '';
    overlayMsg.textContent   = m ?? '';

    // 前回のアニメクラスをクリア
    overlayImg.classList.remove('appeal-scale');

    if(img){
      overlayImg.src = img.src;
      overlayImg.style.display='block';
      overlayImg.classList.add('appeal-scale'); // ← 前後（拡大縮小）バウンド演出
    }else{
      overlayImg.style.display='none';
    }
    overlay.style.display='grid';
  }
  function hideOverlay(){
    overlay.style.display='none';
    overlayImg.style.display='none';
    overlayImg.classList.remove('appeal-scale');
  }
  function fitCanvasToCSSPixelSize(){
    const ratio=window.devicePixelRatio||1, r=canvas.getBoundingClientRect();
    const w=Math.floor(r.width), h=Math.floor(r.height);
    if(canvas.width!==w*ratio||canvas.height!==h*ratio){ canvas.width=w*ratio; canvas.height=h*ratio; ctx.setTransform(ratio,0,0,ratio,0,0); }
  }
  function loadImage(src, {optional=false}={}){
    return new Promise((res)=>{
      const im=new Image();
      im.onload=()=>res(im);
      im.onerror=()=>res(optional?null:im);
      im.src=src;
    });
  }
  function keepSpeed(ball){
    const m = Math.hypot(ball.dx, ball.dy) || 1;
    const s = ball.targetSpeed ?? m;
    const k = s / m;
    ball.dx *= k; ball.dy *= k;
  }

  // ===== スケール計算 =====
  function computeScale(){
    const headerH = document.querySelector('header').offsetHeight;
    const footerH = document.querySelector('footer').offsetHeight;
    const availableH = window.innerHeight - headerH - footerH - 16;
    const wrapW = document.querySelector('.wrap').clientWidth || 960;

    const imageW0 = Math.max(100, Math.round(wrapW - SIDE_PAD_BASE*2));
    const imageH0 = Math.round(imageW0*(ROWS/COLS));
    const desiredH0 = TOP_OFFSET_BASE + EXTRA_TOP_MARGIN_BASE + imageH0 + PLAY_AREA_BASE;

    const sH = availableH > 0 ? Math.min(1, availableH / desiredH0) : 1;
    return sH;
  }

  // ===== レイアウト & 初期化 =====
  async function loadStageImages(stageIndex){
    const def = STAGES[Math.min(stageIndex, STAGES.length-1)];
    let [b, g] = await Promise.all([
      loadImage(def.block, {optional:true}),
      loadImage(def.bg,    {optional:true})
    ]);
    if(!b) b = blockImg;
    if(!g) g = bgImg;
    return [b||blockImg, g||bgImg];
  }

  async function layoutAndInit({keep=false, showReady=true, stageChange=false, newGame=false}={}){
    const wrapW=document.querySelector('.wrap').clientWidth || 960;
    const scale = computeScale();

    const TOP_OFFSET  = Math.round(TOP_OFFSET_BASE * scale);
    const EXTRA_TOP_MARGIN = Math.round(EXTRA_TOP_MARGIN_BASE * scale);
    const PLAY_AREA   = Math.round(PLAY_AREA_BASE * scale);
    const PADDLE_GAP  = Math.round(PADDLE_GAP_BASE * scale);
    const SIDE_PAD    = Math.round(SIDE_PAD_BASE * scale);
    const SIDE_GUTTER = Math.round(SIDE_GUTTER_BASE * scale);

    const imageW0 = Math.max(100, Math.round(wrapW - SIDE_PAD*2));
    const imageW  = Math.round(imageW0 * BRICK_SCALE);
    const imageH  = Math.round(imageW * (ROWS/COLS));

    const Wcss = wrapW;
    const Hcss = TOP_OFFSET + EXTRA_TOP_MARGIN + imageH + PLAY_AREA;

    canvas.style.width = Wcss + 'px';
    canvas.style.height= Hcss + 'px';
    fitCanvasToCSSPixelSize();

    const W = canvas.getBoundingClientRect().width;
    const H = canvas.getBoundingClientRect().height;

    // ステージ情報（色＆スピード倍率）
    const stageIndex = Math.min((state.stage || 1) - 1, STAGES.length - 1);
    const stageDef   = STAGES[stageIndex] || {};
    const speedMul   = stageDef.speedMul ?? 1.0;
    const ballColor  = stageDef.ballColor ?? '#ffd166';

    if(stageChange){
      [blockImg, bgImg] = await loadStageImages(stageIndex);
    }

    const startX = Math.round((Wcss - imageW)/2);
    const startY = TOP_OFFSET + EXTRA_TOP_MARGIN;

    const leftBound  = startX;
    const rightBound = startX + imageW;

    const bricksStartX = startX + SIDE_GUTTER;
    const usableW      = Math.max(60, imageW - SIDE_GUTTER*2);

    const colB = bands(usableW, COLS);
    const rowB = bands(imageH, ROWS);

    const srcColB=bands((blockImg?.width??600),COLS);
    const srcRowB=bands((blockImg?.height??360),ROWS);

    const bricks=[];
    for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
      bricks.push({
        r,c,
        x: bricksStartX + colB[c],
        y: startY + rowB[r],
        w: colB[c+1]-colB[c],
        h: rowB[r+1]-rowB[r],
        alive:true,
        sx:srcColB[c], sy:srcRowB[r],
        sw:srcColB[c+1]-srcColB[c], sh:srcRowB[r+1]-srcRowB[r]
      });
    }

    const paddle={ x:(leftBound + (imageW - BASE.paddleW*scale)/2), y:startY+imageH+PADDLE_GAP, w:BASE.paddleW*scale, h:BASE.paddleH*scale, speed:22*scale };

    const base=BASE.startSpeed*(W/960)*speedMul;
    const s=Math.hypot(base,base);
    const ball={ x:leftBound + imageW*0.5, y:paddle.y-20*scale, dx:(rand(-1,1)<0?-base:base), dy:-base,
                 r:BASE.ballR*scale, maxSpeed:(BASE.maxSpeed*(W/960))*speedMul,
                 targetSpeed:s };
    keepSpeed(ball);

    let baseState;
    if(newGame){
      baseState = { score:0, lives:5, stage:1 };
    }else if(state && (keep || stageChange)){
      baseState = { score:state.score, lives:state.lives, stage:state.stage };
    }else{
      baseState = { score:0, lives:5, stage:state?.stage ?? 1 };
    }

    state = Object.assign(baseState, {
      W,H,startX,startY,imageW,imageH,
      leftBound, rightBound,
      bricks, bricksLeft:bricks.length,
      paddle, ball, keys:{left:false,right:false,a:false,d:false},
      won:false, wonStage:false, resumeReady:false, clapPlayed:state?.clapPlayed ?? false,
      scale, PADDLE_GAP, PLAY_AREA,
      ballColor
    });
    updateHUD();
    if(showReady) showOverlay(`準備OK（STAGE ${state.stage}）`,'スタートで開始 / タッチ操作OK'); else hideOverlay();
  }

  // ===== 描画 =====
  function drawBg(){
    // 外＝白
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, state.W, state.H);

    // 内＝#111111
    ctx.fillStyle = '#111111';
    ctx.fillRect(state.leftBound, 0, state.rightBound - state.leftBound, state.H);

    // ブロック領域と同じ範囲で背景
    if(bgImg){
      const gutter = Math.round(SIDE_GUTTER_BASE * state.scale);
      ctx.drawImage(bgImg, state.startX + gutter, state.startY, state.imageW - gutter*2, state.imageH);
    }

    // 壁ガイド
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(state.leftBound + 0.5, 0);  ctx.lineTo(state.leftBound + 0.5, state.H);
    ctx.moveTo(state.rightBound - 0.5, 0); ctx.lineTo(state.rightBound - 0.5, state.H);
    ctx.stroke();
  }

  function drawBricks(){
    for(const b of state.bricks){
      if(!b.alive) continue;
      if(blockImg){
        ctx.drawImage(blockImg, b.sx,b.sy,b.sw,b.sh, b.x,b.y,b.w,b.h);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(b.x + 0.5, b.y + 0.5, b.w - 1, b.h - 1);
      }else{
        ctx.fillStyle='#334'; ctx.fillRect(b.x,b.y,b.w,b.h);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(b.x + 0.5, b.y + 0.5, b.w - 1, b.h - 1);
      }
    }
  }
  function drawPaddle(){ const p=state.paddle; ctx.fillStyle='#e2e5ff'; ctx.fillRect(p.x,p.y,p.w,p.h); }
  function drawBall(){ const b=state.ball; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fillStyle=(state.ballColor||'#ffd166'); ctx.fill(); }

  // ===== 物理 =====
  function blockCollision(){
    const b=state.ball;
    for(const brick of state.bricks){
      if(!brick.alive) continue;
      if (b.x + b.r < brick.x || b.x - b.r > brick.x + brick.w ||
          b.y + b.r < brick.y || b.y - b.r > brick.y + brick.h) continue;

      const prevX=b.x - b.dx*0.010, prevY=b.y - b.dy*0.010;
      const hitL=prevX <= brick.x - b.r, hitR=prevX >= brick.x + brick.w + b.r;
      const hitT=prevY <= brick.y - b.r, hitB=prevY >= brick.y + brick.h + b.r;
      if (hitL || hitR) b.dx*=-1; else if (hitT || hitB) b.dy*=-1; else b.dy*=-1;

      keepSpeed(b);
      try {
  if (soundOn) {
    const st = state.stage || 1;
    const se = (st >= 2) ? seHit2 : seHit; // ★ ステージ2以降は別音
    se.currentTime = 0;
    se.play();
  }
} catch(e){}


      brick.alive=false; state.bricksLeft--; state.score+=10; updateHUD();
      break;
    }
  }

  function update(dt){
    const {W,H,paddle,ball,keys,leftBound,rightBound}=state;
    keepSpeed(ball);

    if(keys.left||keys.a)  paddle.x -= paddle.speed*dt*60;
    if(keys.right||keys.d) paddle.x += paddle.speed*dt*60;
    paddle.x = clamp(paddle.x, leftBound, rightBound - paddle.w);

    const steps=3;
    for(let i=0;i<steps;i++){
      ball.x += (ball.dx*dt)/steps;
      ball.y += (ball.dy*dt)/steps;

      if(ball.x - ball.r < leftBound){ ball.x=leftBound + ball.r; ball.dx*=-1; keepSpeed(ball); }
      if(ball.x + ball.r > rightBound){ ball.x=rightBound - ball.r; ball.dx*=-1; keepSpeed(ball); }
      if(ball.y - ball.r < 0){ ball.y=ball.r; ball.dy*=-1; keepSpeed(ball); }

      if (ball.y + ball.r >= paddle.y && ball.y + ball.r <= paddle.y + paddle.h &&
          ball.x >= paddle.x && ball.x <= paddle.x + paddle.w && ball.dy > 0){
        const hit=(ball.x-(paddle.x+paddle.w/2))/(paddle.w/2);
        const angle=hit*(Math.PI*0.35);
        const s = Math.min(ball.targetSpeed, ball.maxSpeed);
        ball.dx=Math.sin(angle)*s;
        ball.dy=-Math.cos(angle)*s;
        ball.y=paddle.y - ball.r - 0.01;
        keepSpeed(ball);
      }

      blockCollision();
      if(state.bricksLeft===0) break;
    }

    if(ball.y - ball.r > H){
      const stageIndex = Math.min((state.stage || 1) - 1, STAGES.length - 1);
      const speedMul   = (STAGES[stageIndex]?.speedMul ?? 1.0);
      const base       = BASE.startSpeed * (W/960) * speedMul;
      const s          = Math.hypot(base,base);

      state.lives--; updateHUD(); running=false;
      if(state.lives<=0){
        showOverlay('ゲームオーバー','スタート / R で最初から');
        state.resumeReady = false;
      }else{
        showOverlay('ミス','スタートで続きから再開（残機 '+state.lives+'）');
        Object.assign(state.ball,{
          x:leftBound + (state.imageW*0.5),
          y:state.paddle.y-20*state.scale,
          dx:(rand(-1,1)<0?-base:base), dy:-base,
          targetSpeed:s,
          maxSpeed:(BASE.maxSpeed*(W/960))*speedMul
        });
        keepSpeed(state.ball);
        state.resumeReady = true;
      }
    }

    if(state.bricksLeft===0 && !state.won && !state.wonStage){
      const lastStage = (state.stage >= STAGES.length);
      running=false;
      if(lastStage){
        state.won=true;
        try { if(soundOn && !state.clapPlayed){ seClap.currentTime=0; seClap.play(); state.clapPlayed=true; } } catch(e){}
        showOverlayWithImage('', 'スタート / R で最初から', endImg);
      }else{
        state.wonStage=true;
        showOverlay(`STAGE ${state.stage} CLEAR`, `スタートで STAGE ${state.stage+1} へ`);
      }
    }
  }

  // ===== ループ =====
  function loop(ts){
    if(!running || paused){ lastTime=ts; requestAnimationFrame(loop); return; }
    const dt=Math.min(0.033,(ts-lastTime)/1000)||0.016; lastTime=ts;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBg(); drawBricks(); drawPaddle(); drawBall(); update(dt);
    requestAnimationFrame(loop);
  }

  // ===== 入力 / UI =====
  async function startGame(forceReset=false){
    // ミス後の続き
    if(!forceReset && state.resumeReady && state.lives > 0 && !state.won && !state.wonStage){
      hideOverlay(); state.resumeReady = false; running = true; paused = false; return;
    }
    // 次ステージへ
    if(state.wonStage && !state.won){
      state.wonStage=false;
      state.stage += 1; updateHUD();
      await layoutAndInit({keep:false, showReady:false, stageChange:true, newGame:false});
      hideOverlay(); running=true; paused=false; return;
    }
    // 新規 / 完全リスタート
    hideOverlay();
    state.clapPlayed=false;
    state.score=0; state.lives=5; state.stage=1; state.won=false; state.wonStage=false;
    await layoutAndInit({keep:false, showReady:false, stageChange:true, newGame:true});
    running=true; paused=false;
  }

  function togglePause(){ if(!running) return; paused=!paused; if(paused) showOverlay('ポーズ','スタート / ポーズで再開'); else hideOverlay(); }

  // キーボード（PC）
  window.addEventListener('keydown',e=>{
    if(['ArrowLeft','ArrowRight','Space','KeyA','KeyD','KeyR'].includes(e.code)) e.preventDefault();
    if(e.code==='ArrowLeft') state.keys.left=true;
    if(e.code==='ArrowRight') state.keys.right=true;
    if(e.code==='KeyA') state.keys.a=true;
    if(e.code==='KeyD') state.keys.d=true;
    if(e.code==='Space'){ if(!running) startGame(); else togglePause(); }
    if(e.code==='KeyR'){ startGame(true); }
  }, { passive:false });
  window.addEventListener('keyup',e=>{
    if(e.code==='ArrowLeft') state.keys.left=false;
    if(e.code==='ArrowRight') state.keys.right=false;
    if(e.code==='KeyA') state.keys.a=false;
    if(e.code==='KeyD') state.keys.d=false;
  });

  // タッチ/マウス（スマホ強化：preventDefault 付き）
  function movePaddleByClientX(clientX){
    const r=canvas.getBoundingClientRect();
    const mid=(clientX - r.left) - state.paddle.w/2;
    state.paddle.x = clamp(mid, state.leftBound, state.rightBound - state.paddle.w);
  }
  canvas.addEventListener('pointerdown', e=>{ e.preventDefault(); movePaddleByClientX(e.clientX); }, { passive:false });
  canvas.addEventListener('pointermove', e=>{ e.preventDefault(); movePaddleByClientX(e.clientX); }, { passive:false });

  btnStart.addEventListener('click',()=>startGame());
  btnPause.addEventListener('click',()=>togglePause());
  btnSound.addEventListener('click',()=>{
    soundOn = !soundOn;
    localStorage.setItem('soundOn', soundOn ? '1':'0');
    applySoundState();
  });

  // 起動時ロード
  (async ()=>{
    try{
      [blockImg,bgImg,endImg]=await Promise.all([
        loadImage(STAGES[0].block), loadImage(STAGES[0].bg), loadImage(END_IMG_SRC)
      ]);
    }catch{}
    await layoutAndInit({keep:false, showReady:true, stageChange:false, newGame:true});
    showOverlay('準備OK（STAGE 1）','スタートで開始。タッチでパドルを動かせます。');
    requestAnimationFrame(loop);
  })();

  // リサイズ
  window.addEventListener('resize',()=>{
    if(state?.won) return;
    const run=running;
    layoutAndInit({keep:true, showReady:!run, stageChange:false, newGame:false});
    const ratio=window.devicePixelRatio||1; ctx.setTransform(ratio,0,0,ratio,0,0);
    if(run) hideOverlay();
  });

  // 自動再生制限対策（効果音の解錠）
  window.addEventListener('pointerdown', () => {
  try { seHit.play().then(()=>seHit.pause()); } catch(e){}
  try { seClap.play().then(()=>seClap.pause()); } catch(e){}
  try { seHit2.play().then(()=>seHit2.pause()); } catch(e){} // ★ 追加
}, { once:true });


})();
</script>
</body>
</html>
