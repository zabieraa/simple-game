<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>ブロック崩し（ザビエラー長谷川とたびお）</title>
<style>
  :root { --panel:#171a2b; --text:#e6e8f2; }
  *{box-sizing:border-box}
  html, body { height:100%; }
  body{
    margin:0;background:#0b0e1a;color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Noto Sans JP","Yu Gothic",sans-serif;
    display:grid;place-items:center;min-height:100vh;
    overscroll-behavior: contain;
    -webkit-tap-highlight-color: transparent;
  }
  .wrap{width:min(980px,94vw)}
  header{display:grid;gap:.6rem;grid-template-columns:1fr auto;align-items:center;margin:12px 0}
  h1{margin:0;font-size:clamp(18px,2.6vw,24px)}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{
    background:#171a2b;color:#e6e8f2;border:1px solid #2b3050;padding:10px 12px;border-radius:12px;font:inherit;cursor:pointer
  }
  .controls button.muted{opacity:.7; border-style:dashed}
  .stat{display:flex;gap:10px;flex-wrap:wrap;background:#121426b8;border:1px solid #272b46;padding:8px 12px;border-radius:12px;font-variant-numeric:tabular-nums}
  .canvas-wrap{
    position:relative;border:1px solid #2a2f4d;border-radius:16px;overflow:hidden;box-shadow:0 10px 30px #0008;background:#060814;
    touch-action:none;
    -webkit-user-select:none; user-select:none;
  }
  canvas{
    display:block;width:100%;height:auto;
    touch-action:none;
  }
  .overlay{position:absolute;inset:0;display:none;place-items:center;pointer-events:none;text-align:center;padding:20px}
  .overlay .panel{
    pointer-events:auto;background:#0b0e1acc;border:1px solid #2a2f4d;border-radius:14px;padding:18px 20px;max-width:min(92%,820px);
    max-height:92vh; overflow:auto;
  }
  .overlay h2{margin:0 0 10px;font-size:clamp(18px,3vw,24px)}
  .overlay img{
    max-width:100%; height:auto; display:none; border-radius:12px;
    max-height:calc(92vh - 120px); object-fit:contain;
  }
  footer{opacity:.75;font-size:12px;margin:10px 2px 0; text-align:center}

  @media (max-width: 640px){
    .controls button { padding:12px 14px; border-radius:14px; }
    .stat{ padding:10px 14px; border-radius:14px; }
  }

  /* === エンディング画像のアピール（前後バウンド） === */
  @keyframes popIn {
    0%   { transform: scale(.8); opacity:.0; }
    60%  { transform: scale(1.06); opacity:1; }
    100% { transform: scale(1); }
  }
  @keyframes scaleBounce {
    0%, 100% { transform: scale(1); }
    50%      { transform: scale(1.15); }
  }
  .appeal-scale {
    animation: popIn .42s ease-out both,
               scaleBounce 2.0s ease-in-out .42s infinite;
    will-change: transform;
  }
  @media (prefers-reduced-motion: reduce) {
    .appeal-scale { animation: none !important; }
  }

  /* === 既存の「大きめ表示」枠（必要に応じて継続使用） === */
  .overlay .panel.big { max-width: min(99%, 1100px); padding: 12px 14px; }
  .overlay img.big    { max-height: 98vh; }

  /* === フルスクリーンのオーバーレイ（ミス時に使用） === */
/* iOS/Androidの動的ビューポート高に対応 */
@supports (height: 100dvh) {
  .overlay.full .panel { height: 100dvh; }
  .overlay.full img { max-height: calc(100dvh - 160px); }
}

/* ノッチ等のセーフエリア下端に余白を確保（必要なら） */
@supports (padding: env(safe-area-inset-bottom)) {
  .overlay.full .panel { padding-bottom: env(safe-area-inset-bottom); }
}

  .overlay.full { padding: 0; }
  .overlay.full .panel{
    max-width: none;
    max-height: none;
    width: 100vw;
    height: 100vh;
    border-radius: 0;
    border: none;
    background: #0b0e1acc;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden; /* スクロールさせない */
  }
  .overlay.full img{
    max-width: 98vw;
    max-height: 98vh;
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ブロック崩し（ザビエラー長谷川とたびお）</h1>
      <div class="controls">
        <button id="btnStart">スタート / リスタート</button>
        <button id="btnPause">ポーズ</button>
        <button id="btnSound" aria-pressed="true" aria-label="サウンドON/OFF">🔊 サウンドON</button>
        <span class="stat">
          スコア:<strong id="score">0</strong>　
          残機:<strong id="lives">3</strong>　
          ステージ:<strong id="stage">1</strong>
        </span>
      </div>
    </header>

    <div class="canvas-wrap">
      <canvas id="game" width="960" height="640" aria-label="ゲームキャンバス"></canvas>
      <div class="overlay" id="overlay">
        <div class="panel">
          <h2 id="overlayTitle">準備OK</h2>
          <p id="overlayMsg">スタートで開始。← → / マウス / タッチで操作。（R: リスタート）</p>
          <img id="overlayImg" alt="overlay image" />
        </div>
      </div>
    </div>

    <footer>
      ザビエラー長谷川とたびおのブロック崩しゲーム。
    </footer>
  </div>

<script>
(() => {
  // ===== ステージ構成 =====
  const STAGES = [
    { block: 'block.png',  bg: 'grh.png',  ballColor: '#ffd166', speedMul: 1.00 },
    { block: 'block2.png', bg: 'grh2.png', ballColor: '#7fd8ff', speedMul: 1.25 } // ステージ2は1.25倍
  ];
  const END_IMG_SRC   = 'end.png';
  const BALL_IMG_SRC  = 'kao.png';   // ボール画像
  const MISS_IMG_SRC  = 'kao2.png';  // ミス時の画像

  // ===== 基準レイアウト =====
  const ROWS=4, COLS=8;
  const TOP_OFFSET_BASE=10;
  const EXTRA_TOP_MARGIN_BASE=48;
  const PLAY_AREA_BASE=360;
  const PADDLE_GAP_BASE=230;
  const SIDE_PAD_BASE=18;
  const SIDE_GUTTER_BASE=38;

  const BRICK_SCALE = 0.55;

  // スピード
  const SPEED_MULT=38;
  const BASE = {
    paddleW:110, paddleH:14, ballR:35, // ボール大きめ
    startSpeed:5.3*SPEED_MULT, maxSpeed:14+3*SPEED_MULT
  };

  // ===== 当たり判定の調整用パラメータ =====
  // 数字を下げるほど拾いにくく（=ミスになりやすく）なります
  const HIT_TUNE = {
    edgeInflateRatio: 0.15, // 連続判定で広げる横幅（ボール半径×この割合）
    rectInflateRatio: 0.10, // 矩形交差の横広げ幅（同上）
    minOverlapPx: 5.5       // これ未満の“かすり”は無効
  };

  // ===== DOM =====
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d', { alpha: false });
  const scoreEl=document.getElementById('score');
  const livesEl=document.getElementById('lives');
  const stageEl=document.getElementById('stage');
  const overlay=document.getElementById('overlay');
  const overlayPanel=document.querySelector('.overlay .panel');
  const overlayTitle=document.getElementById('overlayTitle');
  const overlayMsg=document.getElementById('overlayMsg');
  const overlayImg=document.getElementById('overlayImg');
  const btnStart=document.getElementById('btnStart');
  const btnPause=document.getElementById('btnPause');
  const btnSound=document.getElementById('btnSound');

  // ===== 効果音 =====
  const seHit   = new Audio('hit.mp3');   seHit.volume  = 0.6;  // ブロック
  const seHit2  = new Audio('hit2.mp3');  seHit2.volume = 0.6;  // ブロック(Stage2)
  const seKabe  = new Audio('kabe.mp3');  seKabe.volume = 0.55; // 壁＆天井
  const seMiss  = new Audio('miss.mp3');  seMiss.volume = 0.7;  // ミス
  const seClap  = new Audio('clap.mp3');  seClap.volume = 0.7;  // クリア
  let soundOn = (localStorage.getItem('soundOn') ?? '1') === '1';
  function applySoundState(){
    seHit.muted  = !soundOn;
    seHit2.muted = !soundOn;
    seKabe.muted = !soundOn;
    seMiss.muted = !soundOn;
    seClap.muted = !soundOn;
    btnSound.classList.toggle('muted', !soundOn);
    btnSound.setAttribute('aria-pressed', soundOn ? 'true' : 'false');
    btnSound.textContent = soundOn ? '🔊 サウンドON' : '🔇 サウンドOFF';
  }
  applySoundState();

  // ===== 状態 =====
  let blockImg=null, bgImg=null, endImg=null, ballImg=null, missImg=null;
  let state={}, running=false, paused=false, lastTime=0;

  // ===== ユーティリティ =====
  const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const bands=(t,p)=>Array.from({length:p+1},(_,i)=>Math.round(i*t/p));
  function updateHUD(){ scoreEl.textContent=state.score; livesEl.textContent=state.lives; stageEl.textContent=state.stage; }
  function showOverlay(t,m){ if(t!=null)overlayTitle.textContent=t; if(m!=null)overlayMsg.textContent=m; overlayImg.style.display='none'; overlay.style.display='grid'; }

  // 画像付きオーバーレイ（オプション：bigImage / scale / noAnim / fullscreen）
  function showOverlayWithImage(t, m, img, opts = {}){
    const big        = !!opts.bigImage;
    const wantScale  = (typeof opts.scale === 'number') ? opts.scale : 1;
    const noAnim     = !!opts.noAnim;
    const fullscreen = !!opts.fullscreen;

    overlayTitle.textContent = t ?? '';
    overlayMsg.textContent   = m ?? '';

    // クラス初期化
    overlay.classList.toggle('full', fullscreen);
    overlayImg.classList.remove('appeal-scale','big');
    overlayPanel.classList.toggle('big', !fullscreen && big);
    overlayImg.style.transform = '';
    overlayImg.style.transformOrigin = 'center center';

    if(img){
      overlayImg.src = img.src;
      overlayImg.style.display='block';

      if (!noAnim && !fullscreen) overlayImg.classList.add('appeal-scale');
      if (!fullscreen && big)     overlayImg.classList.add('big');

      const applyScale = () => {
        if (wantScale === 1) return;
        const vw = window.innerWidth  * (fullscreen ? 0.98 : 0.92);
        const vh = window.innerHeight * (fullscreen ? 0.98 : 0.92);
        const iw = img.naturalWidth  || img.width  || overlayImg.naturalWidth  || overlayImg.width  || 1;
        const ih = img.naturalHeight || img.height || overlayImg.naturalHeight || overlayImg.height || 1;
        const maxScaleByW = vw / iw;
        const maxScaleByH = vh / ih;
        const maxScale    = Math.max(0.1, Math.min(maxScaleByW, maxScaleByH));
        const finalScale  = Math.min(wantScale, maxScale);
        overlayImg.style.transform = `scale(${finalScale})`;
      };

      if ((img.naturalWidth || img.width) && (img.naturalHeight || img.height)) {
        applyScale();
      } else {
        overlayImg.onload = () => { applyScale(); overlayImg.onload = null; };
      }
    }else{
      overlayImg.style.display='none';
    }
    overlay.style.display='grid';
  }

  function hideOverlay(){
    overlay.style.display='none';
    overlay.classList.remove('full');
    overlayImg.style.display='none';
    overlayImg.classList.remove('appeal-scale','big');
    overlayImg.style.transform = '';
    overlayPanel.classList.remove('big');
  }

  function fitCanvasToCSSPixelSize(){
    const ratio=window.devicePixelRatio||1, r=canvas.getBoundingClientRect();
    const w=Math.floor(r.width), h=Math.floor(r.height);
    if(canvas.width!==w*ratio||canvas.height!==h*ratio){ canvas.width=w*ratio; canvas.height=h*ratio; ctx.setTransform(ratio,0,0,ratio,0,0); }
  }
  function loadImage(src, {optional=false}={}){
    return new Promise((res)=>{
      const im=new Image();
      im.onload=()=>res(im);
      im.onerror=()=>res(optional?null:im);
      im.src=src;
    });
  }
  function keepSpeed(ball){
    const m = Math.hypot(ball.dx, ball.dy) || 1;
    const s = ball.targetSpeed ?? m;
    const k = s / m;
    ball.dx *= k; ball.dy *= k;
  }

  // ===== スケール計算 =====
  function computeScale(){
    const headerH = document.querySelector('header').offsetHeight;
    const footerH = document.querySelector('footer').offsetHeight;
    const availableH = window.innerHeight - headerH - footerH - 16;
    const wrapW = document.querySelector('.wrap').clientWidth || 960;

    const imageW0 = Math.max(100, Math.round(wrapW - SIDE_PAD_BASE*2));
    const imageH0 = Math.round(imageW0*(ROWS/COLS));
    const desiredH0 = TOP_OFFSET_BASE + EXTRA_TOP_MARGIN_BASE + imageH0 + PLAY_AREA_BASE;

    const sH = availableH > 0 ? Math.min(1, availableH / desiredH0) : 1;
    return sH;
  }

  // ===== レイアウト & 初期化 =====
  async function loadStageImages(stageIndex){
    const def = STAGES[Math.min(stageIndex, STAGES.length-1)];
    let [b, g] = await Promise.all([
      loadImage(def.block, {optional:true}),
      loadImage(def.bg,    {optional:true})
    ]);
    if(!b) b = blockImg;
    if(!g) g = bgImg;
    return [b||blockImg, g||bgImg];
  }

  async function layoutAndInit({keep=false, showReady=true, stageChange=false, newGame=false}={}){
    const wrapW=document.querySelector('.wrap').clientWidth || 960;
    const scale = computeScale();

    const TOP_OFFSET  = Math.round(TOP_OFFSET_BASE * scale);
    const EXTRA_TOP_MARGIN = Math.round(EXTRA_TOP_MARGIN_BASE * scale);
    const PLAY_AREA   = Math.round(PLAY_AREA_BASE * scale);
    const PADDLE_GAP  = Math.round(PADDLE_GAP_BASE * scale);
    const SIDE_PAD    = Math.round(SIDE_PAD_BASE * scale);
    const SIDE_GUTTER = Math.round(SIDE_GUTTER_BASE * scale);

    const imageW0 = Math.max(100, Math.round(wrapW - SIDE_PAD*2));
    const imageW  = Math.round(imageW0 * BRICK_SCALE);
    const imageH  = Math.round(imageW * (ROWS/COLS));

    const Wcss = wrapW;
    const Hcss = TOP_OFFSET + EXTRA_TOP_MARGIN + imageH + PLAY_AREA;

    canvas.style.width = Wcss + 'px';
    canvas.style.height= Hcss + 'px';
    fitCanvasToCSSPixelSize();

    const W = canvas.getBoundingClientRect().width;
    const H = canvas.getBoundingClientRect().height;

    // ステージ情報（色＆スピード倍率）
    const stageIndex = Math.min((state.stage || 1) - 1, STAGES.length - 1);
    const stageDef   = STAGES[stageIndex] || {};
    const speedMul   = stageDef.speedMul ?? 1.0;
    const ballColor  = stageDef.ballColor ?? '#ffd166';

    if(stageChange){
      [blockImg, bgImg] = await loadStageImages(stageIndex);
    }

    const startX = Math.round((Wcss - imageW)/2);
    const startY = TOP_OFFSET + EXTRA_TOP_MARGIN;

    const leftBound  = startX;
    const rightBound = startX + imageW;

    const bricksStartX = startX + SIDE_GUTTER;
    const usableW      = Math.max(60, imageW - SIDE_GUTTER*2);

    const colB = bands(usableW, COLS);
    const rowB = bands(imageH, ROWS);

    const srcColB=bands((blockImg?.width??600),COLS);
    const srcRowB=bands((blockImg?.height??360),ROWS);

    const bricks=[];
    for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
      bricks.push({
        r,c,
        x: bricksStartX + colB[c],
        y: startY + rowB[r],
        w: colB[c+1]-colB[c],
        h: rowB[r+1]-rowB[r],
        alive:true,
        sx:srcColB[c], sy:srcRowB[r],
        sw:srcColB[c+1]-srcColB[c], sh:srcRowB[r+1]-srcRowB[r]
      });
    }

    const paddle={ x:(leftBound + (imageW - BASE.paddleW*scale)/2), y:startY+imageH+PADDLE_GAP, w:BASE.paddleW*scale, h:BASE.paddleH*scale, speed:22*scale };

    const base=BASE.startSpeed*(W/960)*speedMul;
    const s=Math.hypot(base,base);
    const ball={ x:leftBound + imageW*0.5, y:paddle.y-20*scale, dx:(rand(-1,1)<0?-base:base), dy:-base,
                 r:BASE.ballR*scale, maxSpeed:(BASE.maxSpeed*(W/960))*speedMul,
                 targetSpeed:s };
    keepSpeed(ball);

    let baseState;
    if(newGame){
      baseState = { score:0, lives:3, stage:1 };
    }else if(state && (keep || stageChange)){
      baseState = { score:state.score, lives:3, stage:state.stage };
    }else{
      baseState = { score:0, lives:3, stage:state?.stage ?? 1 };
    }

    state = Object.assign(baseState, {
      W,H,startX,startY,imageW,imageH,
      leftBound, rightBound,
      bricks, bricksLeft:bricks.length,
      paddle, ball, keys:{left:false,right:false,a:false,d:false},
      won:false, wonStage:false, resumeReady:false, clapPlayed:state?.clapPlayed ?? false,
      scale, PADDLE_GAP, PLAY_AREA,
      ballColor
    });
    updateHUD();
    if(showReady) showOverlay(`準備OK（STAGE ${state.stage}）`,'スタートで開始 / タッチ操作OK'); else hideOverlay();
  }

  // ===== 描画 =====
  function drawBg(){
    // 外＝白
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, state.W, state.H);

    // 内＝#111111
    ctx.fillStyle = '#111111';
    ctx.fillRect(state.leftBound, 0, state.rightBound - state.leftBound, state.H);

    // ブロック領域と同じ範囲で背景
    if(bgImg){
      const gutter = Math.round(SIDE_GUTTER_BASE * state.scale);
      ctx.drawImage(bgImg, state.startX + gutter, state.startY, state.imageW - gutter*2, state.imageH);
    }

    // 壁ガイド
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(state.leftBound + 0.5, 0);  ctx.lineTo(state.leftBound + 0.5, state.H);
    ctx.moveTo(state.rightBound - 0.5, 0); ctx.lineTo(state.rightBound - 0.5, state.H);
    ctx.stroke();
  }

  function drawBricks(){
    for(const b of state.bricks){
      if(!b.alive) continue;
      if(blockImg){
        ctx.drawImage(blockImg, b.sx,b.sy,b.sw,b.sh, b.x,b.y,b.w,b.h);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(b.x + 0.5, b.y + 0.5, b.w - 1, b.h - 1);
      }else{
        ctx.fillStyle='#334'; ctx.fillRect(b.x,b.y,b.w,b.h);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(b.x + 0.5, b.y + 0.5, b.w - 1, b.h - 1);
      }
    }
  }

  // 画像ボール描画（フォールバックで色塗り）
  function drawBall(){
    const b = state.ball;
    if (ballImg) {
      const d = b.r * 2;
      const x = Math.round(b.x - b.r);
      const y = Math.round(b.y - b.r);
      ctx.save();
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.clip();
      ctx.drawImage(ballImg, x, y, d, d);
      ctx.restore();
    } else {
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fillStyle = (state.ballColor || '#ffd166');
      ctx.fill();
    }
  }

  // ===== 物理 =====
  function blockCollision(){
    const b=state.ball;
    for(const brick of state.bricks){
      if(!brick.alive) continue;
      if (b.x + b.r < brick.x || b.x - b.r > brick.x + brick.w ||
          b.y + b.r < brick.y || b.y - b.r > brick.y + brick.h) continue;

      const prevX=b.x - b.dx*0.010, prevY=b.y - b.dy*0.010;
      const hitL=prevX <= brick.x - b.r, hitR=prevX >= brick.x + brick.w + b.r;
      const hitT=prevY <= brick.y - b.r, hitB=prevY >= brick.y + brick.h + b.r;
      if (hitL || hitR) b.dx*=-1; else if (hitT || hitB) b.dy*=-1; else b.dy*=-1;

      keepSpeed(b);

      // ステージに応じたヒットSE（ブロック）
      try {
        if (soundOn) {
          const st = state.stage || 1;
          const se = (st >= 2) ? seHit2 : seHit;
          se.currentTime = 0;
          se.play();
        }
      } catch(e){}

      brick.alive=false; state.bricksLeft--; state.score+=10; updateHUD();
      break;
    }
  }

  function update(dt){
    const {W,H,paddle,ball,keys,leftBound,rightBound}=state;
    keepSpeed(ball);

    if(keys.left||keys.a)  paddle.x -= paddle.speed*dt*60;
    if(keys.right||keys.d) paddle.x += paddle.speed*dt*60;
    paddle.x = clamp(paddle.x, leftBound, rightBound - paddle.w);

    // ==== サブステップ：控えめ設定（拾いすぎ抑制） ====
    const moveX = ball.dx * dt;
    const moveY = ball.dy * dt;
    const dist  = Math.hypot(moveX, moveY);
    // 半径の0.7ごとに1ステップ（以前は0.5）／最低3ステップ
    const steps = Math.max(3, Math.ceil(dist / Math.max(1, ball.r * 0.9)));

    for(let i=0;i<steps;i++){
      const prevX = ball.x;
      const prevY = ball.y;

      ball.x += (ball.dx*dt)/steps;
      ball.y += (ball.dy*dt)/steps;

      // 左右の壁ヒット（SE）
      if(ball.x - ball.r < leftBound){
        ball.x=leftBound + ball.r; ball.dx*=-1; keepSpeed(ball);
        try { if(soundOn){ seKabe.currentTime = 0; seKabe.play(); } } catch(e){}
      }
      if(ball.x + ball.r > rightBound){
        ball.x=rightBound - ball.r; ball.dx*=-1; keepSpeed(ball);
        try { if(soundOn){ seKabe.currentTime = 0; seKabe.play(); } } catch(e){}
      }

      // 天井ヒット（SE）
      if(ball.y - ball.r < 0){
        ball.y = ball.r;
        ball.dy *= -1;
        keepSpeed(ball);
        try { if (soundOn) { seKabe.currentTime = 0; seKabe.play(); } } catch(e){}
      }

      // ==== パドル当たり判定（連続判定＋半径込み・調整版） ====
      if (ball.dy > 0) {
        // 連続判定：上面(y = paddle.y - r)の面交差
        const yTop = paddle.y - ball.r;
        if (prevY <= yTop && ball.y >= yTop) {
          const denom = Math.max(1e-6, (ball.y - prevY));
          const t = (yTop - prevY) / denom;
          const xHit = prevX + t * (ball.x - prevX);

          // 端の拾い幅を縮小
          const edgeInfl = ball.r * HIT_TUNE.edgeInflateRatio;
          const leftB  = paddle.x - edgeInfl;
          const rightB = paddle.x + paddle.w + edgeInfl;
          const inRange = (xHit >= leftB && xHit <= rightB);
          const overlap = Math.min(xHit - leftB, rightB - xHit); // 近い側の余裕量

          if (inRange && overlap >= HIT_TUNE.minOverlapPx) {
            const rel   = (xHit - (paddle.x + paddle.w / 2)) / (paddle.w / 2);
            const angle = rel * (Math.PI * 0.35);
            const s     = Math.min(ball.targetSpeed, ball.maxSpeed);
            ball.dx = Math.sin(angle) * s;
            ball.dy = -Math.cos(angle) * s;
            ball.x = clamp(xHit, paddle.x + ball.r, paddle.x + paddle.w - ball.r);
            ball.y = yTop - 0.01;
            keepSpeed(ball);
            continue;
          }
        }

        // フォールバック：半径込みの矩形交差（横広げを縮小）
        const rectInfl = ball.r * HIT_TUNE.rectInflateRatio;
        if (
          ball.y + ball.r >= paddle.y && prevY <= paddle.y + paddle.h &&
          ball.x + rectInfl >= paddle.x && ball.x - rectInfl <= paddle.x + paddle.w
        ) {
          const rel   = (ball.x - (paddle.x + paddle.w / 2)) / (paddle.w / 2);
          const angle = rel * (Math.PI * 0.35);
          const s     = Math.min(ball.targetSpeed, ball.maxSpeed);
          ball.dx = Math.sin(angle) * s;
          ball.dy = -Math.cos(angle) * s;
          ball.y  = paddle.y - ball.r - 0.01;
          keepSpeed(ball);
        }
      }

      blockCollision();
      if(state.bricksLeft===0) break;
    }

    // ミス処理（落下）
    if(ball.y - ball.r > H){
      const stageIndex = Math.min((state.stage || 1) - 1, STAGES.length - 1);
      const speedMul   = (STAGES[stageIndex]?.speedMul ?? 1.0);
      const base       = BASE.startSpeed * (W/960) * speedMul;
      const s          = Math.hypot(base,base);

      state.lives--; updateHUD(); running=false;

      try { if(soundOn){ seMiss.currentTime = 0; seMiss.play(); } } catch(e){}

      if(state.lives<=0){
        showOverlay('ゲームオーバー','スタート / R で最初から');
        state.resumeReady = false;
      }else{
        showOverlayWithImage(
          '　',
          'New York（残機 '+state.lives+'）',
          missImg,
          { fullscreen:true, scale:2.5, noAnim:true }
        );
        Object.assign(state.ball,{
          x:leftBound + (state.imageW*0.5),
          y:state.paddle.y-20*state.scale,
          dx:(rand(-1,1)<0?-base:base), dy:-base,
          targetSpeed:s,
          maxSpeed:(BASE.maxSpeed*(W/960))*speedMul
        });
        keepSpeed(state.ball);
        state.resumeReady = true;
      }
    }

    // クリア判定
    if(state.bricksLeft===0 && !state.won && !state.wonStage){
      const lastStage = (state.stage >= STAGES.length);
      running=false;
      if(lastStage){
        state.won=true;
        try { if(soundOn && !state.clapPlayed){ seClap.currentTime=0; seClap.play(); state.clapPlayed=true; } } catch(e){}
        showOverlayWithImage('', 'スタート / R で最初から', endImg);
      }else{
        state.wonStage=true;
        showOverlay(`STAGE ${state.stage} CLEAR`, `スタートで STAGE ${state.stage+1} へ`);
      }
    }
  }

  // ===== ループ =====
  function loop(ts){
    if(!running || paused){ lastTime=ts; requestAnimationFrame(loop); return; }
    const dt=Math.min(0.033,(ts-lastTime)/1000)||0.016; lastTime=ts;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBg(); drawBricks(); drawPaddle(); drawBall(); update(dt);
    requestAnimationFrame(loop);
  }

  // ===== 入力 / UI =====
  async function startGame(forceReset=false){
    // ミス後の続き
    if(!forceReset && state.resumeReady && state.lives > 0 && !state.won && !state.wonStage){
      hideOverlay(); state.resumeReady = false; running = true; paused = false; return;
    }
    // 次ステージへ
    if(state.wonStage && !state.won){
      state.wonStage=false;
      state.stage += 1; updateHUD();
      await layoutAndInit({keep:false, showReady:false, stageChange:true, newGame:false});
      hideOverlay(); running=true; paused=false; return;
    }
    // 新規 / 完全リスタート
    hideOverlay();
    state.clapPlayed=false;
    state.score=0; state.lives=3; state.stage=1; state.won=false; state.wonStage=false;
    await layoutAndInit({keep:false, showReady:false, stageChange:true, newGame:true});
    running=true; paused=false;
  }

  function drawPaddle(){ const p=state.paddle; ctx.fillStyle='#e2e5ff'; ctx.fillRect(p.x,p.y,p.w,p.h); }

  function togglePause(){ if(!running) return; paused=!paused; if(paused) showOverlay('ポーズ','スタート / ポーズで再開'); else hideOverlay(); }

  // キーボード（PC）
  window.addEventListener('keydown',e=>{
    if(['ArrowLeft','ArrowRight','Space','KeyA','KeyD','KeyR'].includes(e.code)) e.preventDefault();
    if(e.code==='ArrowLeft') state.keys.left=true;
    if(e.code==='ArrowRight') state.keys.right=true;
    if(e.code==='KeyA') state.keys.a=true;
    if(e.code==='KeyD') state.keys.d=true;
    if(e.code==='Space'){ if(!running) startGame(); else togglePause(); }
    if(e.code==='KeyR'){ startGame(true); }
  }, { passive:false });
  window.addEventListener('keyup',e=>{
    if(e.code==='ArrowLeft') state.keys.left=false;
    if(e.code==='ArrowRight') state.keys.right=false;
    if(e.code==='KeyA') state.keys.a=false;
    if(e.code==='KeyD') state.keys.d=false;
  });

  // タッチ/マウス（スマホ向け）
  function movePaddleByClientX(clientX){
    const r=canvas.getBoundingClientRect();
    const mid=(clientX - r.left) - state.paddle.w/2;
    state.paddle.x = clamp(mid, state.leftBound, state.rightBound - state.paddle.w);
  }
  canvas.addEventListener('pointerdown', e=>{ e.preventDefault(); movePaddleByClientX(e.clientX); }, { passive:false });
  canvas.addEventListener('pointermove', e=>{ e.preventDefault(); movePaddleByClientX(e.clientX); }, { passive:false });

  btnStart.addEventListener('click',()=>startGame());
  btnPause.addEventListener('click',()=>togglePause());
  btnSound.addEventListener('click',()=>{
    soundOn = !soundOn;
    localStorage.setItem('soundOn', soundOn ? '1':'0');
    applySoundState();
  });

  // オーバーレイクリックで開始/再開/リスタート
  function handleOverlayClick(){
    if (getComputedStyle(overlay).display === 'none') return;
    if (paused) { togglePause(); return; }
    startGame();
  }
  overlayPanel.addEventListener('click', (e) => {
    e.preventDefault(); e.stopPropagation(); handleOverlayClick();
  });
  overlayImg.addEventListener('click', (e) => {
    e.preventDefault(); e.stopPropagation(); handleOverlayClick();
  });

  // 起動時ロード
  (async ()=>{
    try{
      [blockImg,bgImg,endImg,ballImg,missImg]=await Promise.all([
        loadImage(STAGES[0].block),
        loadImage(STAGES[0].bg),
        loadImage(END_IMG_SRC),
        loadImage(BALL_IMG_SRC, {optional:true}),
        loadImage(MISS_IMG_SRC, {optional:true})
      ]);
    }catch{}
    await layoutAndInit({keep:false, showReady:true, stageChange:false, newGame:true});
    showOverlay('準備OK（STAGE 1）','スタートで開始。タッチでパドルを動かせます。');
    requestAnimationFrame(loop);
  })();

  // リサイズ
  window.addEventListener('resize',()=>{
    if(state?.won) return;
    const run=running;
    layoutAndInit({keep:true, showReady:!run, stageChange:false, newGame:false});
    const ratio=window.devicePixelRatio||1; ctx.setTransform(ratio,0,0,ratio,0,0);
    if(run) hideOverlay();
  });

  // 自動再生制限対策（各SEを解錠）
  window.addEventListener('pointerdown', () => {
    try { seHit.play().then(()=>seHit.pause()); } catch(e){}
    try { seHit2.play().then(()=>seHit2.pause()); } catch(e){}
    try { seKabe.play().then(()=>seKabe.pause()); } catch(e){}
    try { seMiss.play().then(()=>seMiss.pause()); } catch(e){}
    try { seClap.play().then(()=>seClap.pause()); } catch(e){}
  }, { once:true });

})();
</script>
</body>
</html>
